## Index 설계
- 인덱스 설계의 어려움: 운영으로 넘어가는 순간 인덱스 변경이 쉽지 않음.
	- 새로운 인덱스를 추가하는 방법이 비교적 쉽지만, 무분별하게 인덱스가 생성될 수 있음

#### 가장 기본적인 인덱스 컬럼 선정 기준
[인덱스 스캔 효율성 기준 - 필수]
1. 조건절에 항상 사용하거나 자주 사용하는 컬럼을 인덱스 컬럼으로 선정
	- 항상 사용하는 컬럼을 선두 컬럼으로 선정
2. 등치 조건(=)으로 자주 조회하는 컬럼을 선두 컬럼으로 선정

[그 외 고려해야 할 판단 기준 - 참고]
- 수행 빈도(중요)
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하
- 저장 공간
- 인덱스 관리 비용

---

### NL 조인 시 주의사항
- outer쪽의 비효율보다 inner쪽에서 발생할 수 있는 비효율을 주의해야함
	- inner 쪽 인덱스 스캔 과정에 비효율이 있을 경우 outer -> inner 테이블에 엑세스 횟수만큼 비효율적인 (중복)스캔이 일어날 수 있음
	- 때문에 되도록(중요) inner쪽 인덱스는 '=' 조건 컬럼을 선두에 둬야함.
	- 줄일 수 있다면 테이블 액세스 없이 인덱스에서 필터링을 마치도록 구성해야함

---

### Sort 연산을 생략하기 위한 인덱스 컬럼 추가
```sql
select 계약id, 청약일자, 입력자id, 계약상태코드, 보험시작일자, 보험종료일자
from 계약
where 취급지점id = :trt_brch_id
and 청약일자 between :sbcp_dt1 and :sbcp_dt2
and 입력일자 >= trunc(sysdate - 3)
and 계약상태코드 in (:ctr_stat_cd1, :ctr_stat_cd2, :ctr_stat_cd3)
order by 청약일자, 입력자id
```

IO를 최소화하면서도 소트 연산을 생략하기 위한 방법
1. '=' 연산자로 사용한 조건절 컬럼 선정(취급지점id)
2. order by 절에 기술한 컬럼 추가(청약일자, 입력자id)
3. '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정(입력일자, 계약상태코드)

위 방법을 따라서 => [ 취급지점id + 청약일자 + 입력자id] 순서로 인덱스 생성
- '=' 조건이 아닌 컬럼(입력일자, 계약상태코드)는 맨 뒤에 붙여도되고 안붙여도 됨
	- 위 두 조건을 만족하는 데이터가 많지 않을 경우 인덱스 효율이 올라감(많을경우 인덱스 생략)

---

#### IN 조건은 등치 조건과 다름
- IN 조건이 등치 조건이 될 수 있는것은 IN-List iterator('='과 union all 조합)로 풀릴때 가능

```sql
---if idx: 거주지역 + 혈액형 + 연령
거주지역   혈액형   연령
서울      A      23
서울      A      30
서울      A      45
서울      O      29
서울      O      39
서울      O      49

select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 ='서울'
and 혈액형 in ('A', 'O')
order by 연령

--- 위 코드가 아래 코드와 동일한 결과를 나타낼때 IN -> = + union all로 치환 가능

select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 ='서울'
and 혈액형 = 'A'
union all
select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 ='서울'
and 혈액형 = 'O'
order by 연령
```
- 만약 등치 조건과 union all로 조합할 경우 연령 인덱스 컬럼이 무시됨
	- 첫번째 혈액형('A')가 실행결과와 두번째('O') 혈액형 쿼리 결과 합은 서울에 사는 모든 O형 혈액형 사람들이 A형 사람들보다 많아야 함. 그렇지 않기 때문에 sort를 생략할 수 없음










































