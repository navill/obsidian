## Index 설계
- 인덱스 설계의 어려움: 운영으로 넘어가는 순간 인덱스 변경이 쉽지 않음.
	- 새로운 인덱스를 추가하는 방법이 비교적 쉽지만, 무분별하게 인덱스가 생성될 수 있음

#### 가장 기본적인 인덱스 컬럼 선정 기준
[인덱스 스캔 효율성 기준 - 필수]
1. 조건절에 항상 사용하거나 자주 사용하는 컬럼을 인덱스 컬럼으로 선정
	- 항상 사용하는 컬럼을 선두 컬럼으로 선정
2. 등치 조건(=)으로 자주 조회하는 컬럼을 선두 컬럼으로 선정

[그 외 고려해야 할 판단 기준 - 참고]
- 수행 빈도(중요)
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하
- 저장 공간
- 인덱스 관리 비용

---

### NL 조인 시 주의사항
- outer쪽의 비효율보다 inner쪽에서 발생할 수 있는 비효율을 주의해야함
	- inner 쪽 인덱스 스캔 과정에 비효율이 있을 경우 outer -> inner 테이블에 엑세스 횟수만큼 비효율적인 (중복)스캔이 일어날 수 있음
	- 때문에 되도록(중요) inner쪽 인덱스는 '=' 조건 컬럼을 선두에 둬야함.
	- 줄일 수 있다면 테이블 액세스 없이 인덱스에서 필터링을 마치도록 구성해야함

---

### Sort 연산을 생략하기 위한 인덱스 컬럼 추가
```sql
select 계약id, 청약일자, 입력자id, 계약상태코드, 보험시작일자, 보험종료일자
from 계약
where 취급지점id = :trt_brch_id
and 청약일자 between :sbcp_dt1 and :sbcp_dt2
and 입력일자 >= trunc(sysdate - 3)
and 계약상태코드 in (:ctr_stat_cd1, :ctr_stat_cd2, :ctr_stat_cd3)
order by 청약일자, 입력자id
```

IO를 최소화하면서도 소트 연산을 생략하기 위한 방법
1. '=' 연산자로 사용한 조건절 컬럼 선정
2. order by 절에 기술한 컬럼 추가
3. '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정
위 방법을 따라서 => [ 취급지점id + 청약일자 + 입력자id] 순서로 인덱스 생성
- 






















