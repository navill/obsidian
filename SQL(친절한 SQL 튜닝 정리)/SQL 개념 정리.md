## SQL 최적화
1. SQL 파싱
	- 파싱트리 생성
	- 문법 체크
	- 오류 체크: 의미상 오류가 없는지 확인(테이블 이름 확인 등)
2. SQL 최적화(옵티마이저)
3. 로우 소스 생성: 실행 가능한 코드 또는 프로시저 형태로 포맷팅

- 라이브러리 캐시
	- 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간(System Global Area에 위치함)

 - soft 파싱 & hard 파싱
	 - 사용자 -> SQL 파싱 -> 
		 - 캐시에 존재할 경우 -> 실행(soft 파싱)
		 - 캐시에 존재하지 않을 경우 -> 최적화 -> 로우 소스 생성 -> 실행(hard 파싱)

```sql
select * from customer where login_id = 'a';
select * from customer where login_id = 'b';
select * from customer where login_id = 'c';
select * from customer where login_id = 'd';
select * from customer where login_id = 'e';
...
```
- 위 코드는 전부 같은 동작을 처리 하지만, 각각 최적화를 진행하고 라이브러리 캐시에 각각의 DBMS 내부 프로시저를 위한 별도 공간을 사용함
	- 만약 100만명이 동시에 로그인을 시도할 경우 100만개의 프로시저가 필요함 -> CPU 과부하 원인
	- 바인드 변수를 사용함으로써 위 문제를 해결 할 수 있음
		ex: "select * from customer where login_id = ?"
---
### I/O 매커니즘
![](Users/navill/Documents/Obsidian%20Vault/Pasted%20image%2020240111145932.png)Users/navill/Documents/Obsidian Vault/Pasted image 20240111145932.png
- I/O 작업이 일어날 때 프로세스는 waiting으로 넘어감
	- 데이터를 읽기 위한 I/O 작업이 늘어날 경우 CPU의 대기 시간은 늘어남 -> 성능 저하 원인
- SQL 튜닝은 I/O 작업을 줄이는 작업
---
### 데이터베이스 저장 구조
![](Users/navill/Documents/Obsidian%20Vault/Pasted%20image%2020240111150415.png)- 테이블 스페이스: 논리적 데이터베이스 객체(테이블, 인덱스 등)를 저장하는 물리 공간
	- 테이블 스페이스는 하나 이상의 데이터 파일로 구성됨
- 세그먼트: 논리적 데이터베이스 객체(테이블, 인덱스)를 위한 저장 영역
	- 테이블이나 인덱스는 하나 이상의 세그먼트로 구성
- 익스텐트: 세그먼트를 구성하는 저장 단위
	- 테이블 스페이스 내에서 세그먼트는 여러 익스텐트로 나뉘고, 새로운 데이터가 추가될 때 동적으로 익스텐트가 할당됨
- 블록(DBMS에 따라 페이지라고도 표현): 읽기/쓰기 위한 최소 단위의 저장 공간
	- 일반적으로 4KB ~8KB정도로 고정되어있음
- 로우: 실제로 저장된 데이터 레코드
---
### 결합 인덱스 생성 시 컬럼 배치 순서에 대한 잘못된 이해
- 인덱스 생성 시 "성별 + 이름"과 "이름 + 성별"순으로 컬럼을 배치할 경우
	- 성별 + 이름: 여자인 레코드 25건을 찾고 거기서 이름을 검사해 최종 2명 출력 -> 25번 검사
	- 이름 + 성별: "OOO"레코드 2건을 찾고 거기서 성별을 검사해 최종 2명 출력 -> 2건 검사
- 평면 구조라면 위와같은 설명이 맞지만 B\*Tree 구조의 DMBS에서는 두 인덱스 모두 2건(정확히는 조건을 만족하지 않는 시점을 포함한 세 건)을 스캔함
	- 이름이 "OOO"이면서 "여성"인 첫 번째 컬럼을 바로 찾고 스캔


---

