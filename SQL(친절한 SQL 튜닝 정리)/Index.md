## 어플리케이션 튜닝 vs 배치 프로그램 튜닝
- 어플리케이션: 소량 데이터를 읽고 갱신
	- 인덱스 + NL조인 효과적임
- 배치 프로그램: 대량의 데이터를 읽고 갱신
	- 풀스캔 + 해시 조인 효과적임
	- 초대용량 테이블에서는 파티셔닝(풀스캔 성능 향상을 위함)과 병렬 처리가 필요함

---

## 테이블 엑세스 최소화 방법

**인덱스 컬럼 추가**

```sql
/* index: deptno + job */

select /*+ index(emp emp_x01) */ *
from emp
where deptno = 30
and sal >= 2000
```
- 인덱스 스캔이 완료 된 후 sal 조건문에 의해 테이블 랜덤 엑세스가 일어남
	- deptno=30이 10명 일 경우, sal>=2000을 찾기 위한 랜덤 엑세스 10회 발생
- 개선 방법 
	- 인덱스 추가: 테이블 별 인덱스가 무분별하게 늘어날 수 있음 -> x
	- 인덱스 컬럼 순서 변경: 다른 로직에서 해당 인덱스를 사용하고 있다면? -> x
	- 인덱스 컬럼 추가: 다른 로직에서도 사용 가능하면서 테이블 랜덤 액세스 횟수를 줄일 수 있음 -> O
		- index = deptno + job + sal: 조건에 맞는 인덱스 스캔 이후 테이블 스캔 진행하기 때문에 테이블 랜덤 엑세스 감소


**인덱스만 읽고 처리(Covered index)**
- 쿼리에 사용되는 컬럼이 많지 않을 경우 해당 컬럼으로 구성된 인덱스를 구성하는 방법
- 효과는 좋지만 범용성이 떨어짐


**Include Index**
- 테이블 랜덤 엑세스를 줄이기 위한 용도
- DBMS에 따라 지원하지 않을 수 있음


**Clustered Index(Index-Organized Table)**
- 일반 테이블(heap organization table)과 달리 정렬 순서를 유지하도록 구성된 테이블
	- 인위적으로 CF를 좋게 만드는 방법
	- 랜덤 엑세스가 아닌 시퀀셜 방식으로 데이터 엑세스

**Index Cluster Table**
- 클러스터 키 값이 같은 레코드를 한 블럭에 모아서 저장하는 구조
- 클러스터 인덱스 탐색에서 찾은 키값에 접근하기 위한 엑세스 한 번(클러스터 체인 탐색 제외), 접근하고 시퀀셜 방식으로 스캔 -> 랜덤 엑세스 최소화
	

**Hash Cluster Table**
- 클러스터 키 값을 이용하지 않고 해시 알고리즘을 이용한 방식
---

### 부분 범위 처리
- 부분 범위 처리: 클라이언트로부터 요청(fetch call)이 있을 때 마다 일정량(array size)씩 나누어 전송하는 방식 
	- 단위는 클라이언트(어플리케이션)에서 정의

---
# 인덱스 스캔 효율화

- 랜덤 엑세스 최소화 종류
	- 설계 단계: IOT, 클러스터 테이블, 파티션
	- 운영 단계: 인덱스 컬럼 추가

- 인덱스 스캔 시, 인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아닐 경우(+between, like와 같은 범위 검색 조건) 인덱스 스캔 과정에서 비효율이 발생. 반면 선행 컬럼 조건이 등치 조건일 때 효율이 가장 좋음)
	- ex: a,b,c,d로 구성된 인덱스에서 검색 조건을 where a=1 and b=2 and d=3 이런식으로 사용할 때 선행(c) 컬럼이 누락된 경우를 말함

> between -> in list로 전환
> - 인덱스를 수정하기 어려운 상황이고, 특정 컬럼에 대한 범위 조건이 필요할 경우 between을 in-list로 변경함으로써 테이블 엑세스를 줄일 수 있음 -> between 1 and 3일 경우, 1부터 3까지에 대한 각각의 등치조건을 union 하는 효과
> - 조건: in-list에 사용할 값이 많지 않아야하고, 검색 조건을 만족하는 레코드가 산재되어있을 때 효과적
> 
> 데이터 분포 및 수직적 탐색 비용을 **반드시** 따져보고 사용해야함!

- 인덱스 엑세스 조건: 인덱스 스캔 범위(시작, 종료 지점) 조건
- 인덱스 필터 조건: 데이터에 엑세스할지를 결정하는 조건
	- 위 예시에서는 a,b가 인덱스 엑세스 조건, d가 인덱스 필터 조건
- 테이블 필터 조건(?): 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지를 결정


함수 및 자세한 사용법은 생략
- 책에서 설명하는 방법 중 일부는 ORM optimizer에서 최적화 가능
- 백엔드 개발자에게 정말 필요한 영역인지?(저정도 하드하게 튜닝해야할 경우 DBA의 영역이라고 생각함)
- 현재 내 수준보다 높은 레벨 영역(필요할 때 더 공부하는것이 좋을듯함)
- 지금은 개념과 대략적인 동작 원리를 이해하는 정도로 정리